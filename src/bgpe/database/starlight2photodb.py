'''
Created on Feb 23, 2012

@author: william
'''

import sys
import h5py

import numpy as np

from bgpe.core.exceptions import HDF5dbException
from bgpe.io.readfilterset import readfilterset


class starlight2photo(object):
    '''
        This class is used to convert STARLIGHT (http://www.starlight.ufsc.br)
        output files to appropriate filterset curve responses and redshift.
          It uses a HDF5 database generated by starlight_hdf5convert.py
    '''

    def __init__(self, dr='DR7', base='BS'):
        self.dr = dr
        self.base = base
        #self.filterfile = '/Users/william/mestrado/Simulations/Alhambra_23.filterset'
    
    def slightdb_open(self, slightdb_file):
        try:
            self.slightdb = h5py.File(slightdb_file, 'r')
        except:
            raise HDF5dbException('Cannot open Stalight-SDSS DB %s.',
                                   slightdb_file)
    
    def slightdb_close(self):
        try:
            self.slightdb.close()
        except:
            raise HDF5dbException('Cannot close Stalight-SDSS DB.')
    
    def read_filter(self, filterfile):
        '''
            Reads the filterfile
        '''
        ReadFilterSetObj = readfilterset()
        ReadFilterSetObj.read(filterfile)
        self.filterset = ReadFilterSetObj.filterset
    
        
    def convert(self, slight_id): #TODO: z
        '''
            Converts from Starlight-SDSS database to a 
            Photometry models database (AB magnitudes)
        '''
        #===================================================================
        #    Structure of Starlight-SDSS db:
        # /data_release/input/plate.mjd.fiberID
        # /data_release/output/base/plate.mjd.fiberID
        #===================================================================
        
        # Speed of light
        c = 2.99792458e18 #Angstroms per second
        
        # SDSS arq_obs:
        obs = self.slightdb.get('/%s/input/%s' % 
                                (self.dr, slight_id ) ).value
        #Read Starlight Output file:
        #l_obs 0 f_obs 1 f_syn 2 f_wei 3 Best_f_SSP 4
        out = self.slightdb.get('/%s/output/%s/%s' % 
                                 (self.dr, self.base, slight_id ) )
        fobs_norm = out.attrs.get('fobs_norm')
        syn = out.value
    
        obs['flux'] = obs['flux'] * 1e-17
        obs['err'] = obs['err'] * 1e-17
        syn['flux_obs'] = syn['flux_obs'] * fobs_norm * 1e-17
        syn['flux_syn'] = syn['flux_syn'] * fobs_norm * 1e-17
        
        taux = []
        eaux = []
        for j in np.unique(self.filterset['ID_filter']):
            filter_v = self.filterset[self.filterset['ID_filter'] == j] #TODO: Arrumar esta merda!
            
            #Cut the spectrum on the filterset range
            obs_cut = obs[np.bitwise_and(obs['wl'] >= np.min(filter_v['wl']), obs['wl'] <= np.max(filter_v['wl']))]
            syn_cut = syn[:,np.bitwise_and(syn['wl'] >= np.min(filter_v['wl']), syn['wl'] <= np.max(filter_v['wl']))]
            
            #print np.shape(obs_cut), np.shape(syn_cut), obs_cut, syn_cut
            
            #Check if the filterset is sampled correctly --- TODO: Do this when reading!!
            if(np.any(obs_cut['wl'] != filter_v['wl'])):
                print '@@@> Warning! Filter '+j+' is not sampled the same way as the spectrum. Interpolating...'
                #print np.shape(obs_cut['wl']),np.shape(filterset['wl'][0]),np.shape(filterset['transm'][0])
                wl_ = obs_cut['wl']
                transm_ = np.interp(obs_cut['wl'],filter_v['wl'],filter_v['transm'])
            else:
                wl_ = filter_v['wl']
                transm_ = filter_v['transm']
    
            JLambda = np.max(filter_v['wl'])-np.min(filter_v['wl']) #TODO: Do this when reading!!
            t_lambda = transm_/np.trapz(transm_,wl_) #TODO: Do this when reading!!
            t_lambda_nu = np.trapz( transm_ * c / (wl_**2) ,wl_) #TODO: Do this when reading!!
            
            #Check if the spectrum in the filterset range is ok. Good pixels should be signaled with flag(lambda) = 0 or 1.
            print obs_cut['err']
            n       = len(obs_cut)
            good    = np.bitwise_and(obs_cut['flag'] <= 1, obs_cut['err'] > 0)
            bad     = np.invert(good)
            #i_good  = np.nonzero(good)[0]
            n_bad   = np.sum(bad)
            
            print n, n_bad #, good, bad
                            
            #If we have bad_pixels, we have to manage with it...
            if(n_bad > 0):
                p_bad = np.float(n_bad)/np.float(len(obs_cut))
                if(p_bad > 0.5):
                    #If we have # of bad pixels greater than 50%, then make filterset flux and error equal to inf.
                    taux.append(0)
                    eaux.append(np.inf)
                    #print j+' Too much bad pixels'    #debug
                else:
                    #If we have # of bad pixels less than 50%, we simply neglect this point on the error acoounts,
                    #and make flux = synthetic flux.
                    print np.shape(good), np.shape(bad), np.shape(obs_cut), np.shape(syn_cut)
                    obs_cut['flux'][bad] = syn_cut['flux_syn'][bad]
                    #then, eval the integral for flux
                    taux.append( np.float( np.trapz(obs_cut['flux'] * transm_, wl_) / t_lambda_nu ))
                    #and for the error (SDSS effective resolution == 3 \AA)
                    eaux.append( np.sqrt( JLambda * 3 * np.mean(obs_cut['err'][good]**2 * t_lambda[good]**2) ) ) # TODO: Error propagation
                    #print j+' Some bad pixels'    #debug
            else:
                #If there is no bad pixel, just eval the integral for flux
                taux.append( np.float( np.trapz(obs_cut['flux'] * transm_, wl_) / t_lambda_nu ))
                #and for the error
                eaux.append( np.sqrt( JLambda * 3 * np.mean(obs_cut['err']**2 * t_lambda**2) ) ) # TODO: Error propagation
                #print j+' No bad pixel'    #debug
        
        taux = -2.5 * np.log10( taux ) - 48.6
        taux[taux == np.inf] = 0
        eaux = -2.5 * np.log10( eaux ) - 48.6
        #taux[taux == np.inf] = 0
        
        print taux, eaux
                        
        return np.array(taux), np.array(eaux)
    
    
def main():
    pass
    
if __name__ == '__main__':
    
    #Init starlight2photo
    s2p = starlight2photo()
    #Load Filterset
    s2p.read_filter('/Users/william/mestrado/Simulations/Alhambra_17.filter')
    #Load STARLIGHT-SDSS base
    s2p.slightdb_open('/Users/william/Downloads/BScat_1k.hdf5')
    #Create/Open PhotoDB
    
    #Close PhotoDB
    
    #main(sys.argv[1:])

        